namedWindow("Originale", 1);
	namedWindow("Filtree", 1);
	char c;
	c = (char)waitKey(30);
	while(c != 'q' && !background.empty())
	{
		imshow("Filtree", background);
		imshow("Originale", frame);
		c = (char)waitKey(30);
	}
	
//ancienne fonction de comparaison pour l'extraction
if(pixelColorDifference(frame.at<Vec3b>(i,j), background.at<Vec3b>(i,j), seuil)){

/**
 * Renvoi vrai si la différence entre les couleurs des deux pixels est supérieure au seuil
 */
bool pixelColorDifference(Vec3b pixA, Vec3b pixB, double seuil);

/**
 * Renvoi vrai si la différence entre les couleurs des deux pixels est supérieure au seuil
 */
bool pixelColorDifference(Vec3b pixA, Vec3b pixB, double seuil){

	if(abs(pixA[0] - pixB[0]) > seuil||
			abs(pixA[1] - pixB[1]) > seuil ||
			abs(pixA[2] - pixB[2]) >seuil){
		return true;
	}
	return false;

}

 //res.at<Vec3b>(i,j) = frame.at<Vec3b>(i,j);
 //res.at<Vec3b>(i,j) = Vec3b(255,255,255);
 
 if(abs(frame.at<unsigned char>(i,j) - background.at<unsigned char>(i,j)) > seuil){
 res.at<unsigned char>(i,j) = frame.at<unsigned char>(i,j);
  res.at<unsigned char>(i,j) = 100;
  
  Mat temporalSmoothing(String filename){

    /*Résultat à renvoyer*/
    Mat background;
    /*Ensemble des 10 premières frames de la vidéos*/
    Mat stockage[10];
    /** Video*/
    VideoCapture vc = VideoCapture(filename);
    double h = 0.1;
    int res0, res1, res2;

    /*Récupération des dix premières images*/
    for(int i = 0; i< 10; i++){
        vc >> stockage[i];
    }
    background = Mat(stockage[0].size(), stockage[0].type());

    /*
     * Création d'une image dont chaque pixel correspond à la moyenne des 10 pixels
     * respectifs de chaque image
     */
    for(int x = 0; x < background.rows; x++){
        for(int y = 0; y < background.cols; y ++){
            for(int k = 0; k < 3; k++)
            {
                //calcul de la convolution pour chaque composante couleur
                res0 = res1 = res2 = 0;
                for (int u = 0; u < 10; u++)
                {
					res = res + (h*(stockage[u].at<Vec3b>(x, y)[k]));
                }
                background.at<Vec3b>(x,y)[k] = res;
            }

        }
    }
    vc.release();
    //spatialSmoothingAvgColor(background, 1);
    return background;
}

if (tabCarres[i*colonnes*3+j*3+0] != pow(image.data[i*colonnes*3+j*3+0],2)
 || tabCarres[i*colonnes*3+j*3+1] != pow(image.data[i*colonnes*3+j*3+1],2)
 || tabCarres[i*colonnes*3+j*3+2] != pow(image.data[i*colonnes*3+j*3+2],2))
 	std::cout<<"Valeurs incohérentes"<<std::endl;
 	
 	//test liste
	std::list<int> mylist;
	mylist.push_back (100);
	mylist.push_back (200);
	mylist.push_back (300);
	
	int i = 0;
	int tmp = 0;
	for (std::list<int>::iterator it = mylist.begin(); it != mylist.end();it++)
	{
		if (i<5)
		{
			tmp = mylist.front();
			mylist.pop_front();
			mylist.push_back(tmp+i);
			mylist.push_back(tmp+i);
			std::cout<<"i : "<<i<<std::endl; 
			i++;
		}
	}
	
	for (std::list<int>::iterator it2 = mylist.begin(); it2 != mylist.end();it2++)
	{
		std::cout<<"val : "<<*it2<<std::endl;
	}
	
void Bloc::split(std::list<Bloc*> & blocs, const Mat & image, const unsigned short int tabCarres []){
	//std::cout<<"SPLIT"<<std::endl;
	int size = (p_bd.x - p_hg.x)*(p_bd.y-p_hg.y);
//	std::cout<<"pix_hg : "<<p_hg.x<<" - "<<p_hg.y<<std::endl;
//	std::cout<<"pix_bd : "<<p_bd.x<<" - "<<p_bd.y<<std::endl;
//	std::cout<<"SIZE : "<<size<<std::endl;
	if(size>25)
	{
		//std::cout<<"I'm in"<<std::endl;
		int n = 0;
		int m0,m1,m2;
		double sum1,sum2,sum0;
		m0 = m1 = m2 = 0;
		sum0 = sum1 = sum2 = 0;
		double var0, var1, var2;
		var0 = var1 = var2 = 0;
		int lignes = image.rows;
		int colonnes = image.cols;
		
	
		for (int i = p_hg.y; i < p_bd.y; i++)
		{
			for (int j = p_hg.x; j < p_bd.x; j++)
			{
				if (!(image.data[i*colonnes*3+j*3+0] == BLUE && image.data[i*colonnes*3+j*3+1] == GREEN && image.data[i*colonnes*3+j*3+2] == RED))
				{
					n++;
					//std::cout<<"J'ai trouvé un pixel";
					sum0 += tabCarres[i*colonnes*3+j*3+0];
					sum1 += tabCarres[i*colonnes*3+j*3+1];
					sum2 += tabCarres[i*colonnes*3+j*3+2];
				
					m0 += image.data[i*colonnes*3+j*3+0];
					m1 += image.data[i*colonnes*3+j*3+1];
					m2 += image.data[i*colonnes*3+j*3+2];
	
				}
			}
		}
	
		if (n != 0)
		{
			m0 = m0/n;
			m1 = m1/n;
			m2 = m2/n;
	
			var0 = abs((sum0/n) - pow(m0,2));
			var1 = abs((sum1/n) - pow(m1,2));
			var2 = abs((sum2/n) - pow(m2,2));
		}
		else
		{
			var0 = 0;
			var1 = 0;
			var2 = 0;
		}
		
	
//		std::cout<<"nb_pixels : "<<n<<std::endl;
//		std::cout<<"vars :"<<var0<<" - "<<var1<<" - "<<var2<<std::endl;
	
		if (var0>100 || var1>100 || var2>100) // a faire varier
		{
			//séparation du bloc en 4
			int nvX, nvY;
			nvX = (p_bd.x - p_hg.x)/2;
			nvY = (p_bd.y - p_hg.y)/2;
//			std::cout<<"nvX : "<<nvX<<" - nvY : "<<nvY<<std::endl;
//			std::cout<<std::endl;
			
			Bloc* bloc1  = new Bloc(pixel(p_hg.x, p_hg.y), pixel(nvX+p_hg.x, nvY+p_hg.y)); //OK
			
			Bloc* bloc2  = new Bloc(pixel(nvX+p_hg.x+1, p_hg.y), pixel(p_bd.x, nvY+p_hg.y));
			
			Bloc* bloc3  = new Bloc(pixel(p_hg.x, nvY+p_hg.y+1), pixel(nvX+p_hg.x, p_bd.y));
			
			Bloc* bloc4  = new Bloc(pixel(nvX+p_hg.x+1, nvY+p_hg.y+1), pixel(p_bd.x, p_bd.y)); //OK
			
			//répartion des vosins du bloc d'origine
			
			for (auto it = voisins.begin(); it != voisins.end(); it++)
			{
				//supression du bloc principal en tant que voisin chez ses propres  voisins
				for (auto it2 = (*it)->voisins.begin(); it2 != (*it)->voisins.end(); it2++)
				{
					if (*this == **it2)
					{
						(*it)->voisins.erase(it2);
						break;
					}
				}	
				
				if (bloc1->estVoisin(**it)){
					//std::cout<<"Le bloc 1 a un voisin"<<std::endl;
					bloc1->voisins.push_back(*it);
					(*it)->voisins.push_back(bloc1);
				}
				
				if (bloc2->estVoisin(**it)){
					//std::cout<<"Le bloc 2 a un voisin"<<std::endl;
					bloc2->voisins.push_back(*it);
					(*it)->voisins.push_back(bloc2);
				}
				
				if (bloc3->estVoisin(**it)){
					//std::cout<<"Le bloc 3 a un voisin"<<std::endl;
					bloc3->voisins.push_back(*it);
					(*it)->voisins.push_back(bloc3);
				}
				
				if (bloc4->estVoisin(**it)){
					//std::cout<<"Le bloc 4 a un voisin"<<std::endl;
					bloc4->voisins.push_back(*it);
					(*it)->voisins.push_back(bloc4);
				}
			}
			
			//insertion des nouveaux blocs dans les listes de voisins
			bloc1->voisins.push_back(bloc2);
			bloc1->voisins.push_back(bloc3);
			bloc1->voisins.push_back(bloc4);
			
			bloc2->voisins.push_back(bloc1);
			bloc2->voisins.push_back(bloc3);
			bloc2->voisins.push_back(bloc4);
			
			bloc3->voisins.push_back(bloc1);
			bloc3->voisins.push_back(bloc2);
			bloc3->voisins.push_back(bloc4);
			
			bloc4->voisins.push_back(bloc1);
			bloc4->voisins.push_back(bloc2);
			bloc4->voisins.push_back(bloc3);
			
			//insertion des nouveaux blocs dans la listes
			blocs.push_back(bloc1);
			blocs.push_back(bloc2);
			blocs.push_back(bloc3);
			blocs.push_back(bloc4);
			
			//suppression de l'ancien bloc
			for (auto it = blocs.begin(); it != blocs.end(); it++)
			{
				if (**it == *this){
					blocs.erase(it);
					break;
				}
			}
			delete this;
			//https://isocpp.org/wiki/faq/freestore-mgmt#delete-this

			//on split les nouveau blocs
			bloc1->split(blocs, image, tabCarres);
			bloc2->split(blocs, image, tabCarres);
			bloc3->split(blocs, image, tabCarres);
			bloc4->split(blocs, image, tabCarres);
		}
	}
}

int size = (temp->p_bd.x - temp->p_hg.x)*(temp->p_bd.y-temp->p_hg.y);
	//	std::cout<<"pix_hg : "<<p_hg.x<<" - "<<p_hg.y<<std::endl;
	//	std::cout<<"pix_bd : "<<p_bd.x<<" - "<<p_bd.y<<std::endl;
	//	std::cout<<"SIZE : "<<size<<std::endl;
		if(size>25)
		{
			//std::cout<<"I'm in"<<std::endl;
			int n = 0;
			int m0,m1,m2;
			double sum1,sum2,sum0;
			m0 = m1 = m2 = 0;
			sum0 = sum1 = sum2 = 0;
			double var0, var1, var2;
			var0 = var1 = var2 = 0;
			int lignes = image.rows;
			int colonnes = image.cols;

			for (int i = temp->p_hg.y; i < temp->p_bd.y; i++)
			{
				for (int j = temp->p_hg.x; j < temp->p_bd.x; j++)
				{
					if (!(image.data[i*colonnes*3+j*3+0] == BLUE && image.data[i*colonnes*3+j*3+1] == GREEN && image.data[i*colonnes*3+j*3+2] == RED))
					{
						n++;
						//std::cout<<"J'ai trouvé un pixel";
						sum0 += tabCarres[i*colonnes*3+j*3+0];
						sum1 += tabCarres[i*colonnes*3+j*3+1];
						sum2 += tabCarres[i*colonnes*3+j*3+2];
				
						m0 += image.data[i*colonnes*3+j*3+0];
						m1 += image.data[i*colonnes*3+j*3+1];
						m2 += image.data[i*colonnes*3+j*3+2];
					}
				}
			}
	
			if (n != 0)
			{
				m0 = m0/n;
				m1 = m1/n;
				m2 = m2/n;
	
				var0 = abs((sum0/n) - pow(m0,2));
				var1 = abs((sum1/n) - pow(m1,2));
				var2 = abs((sum2/n) - pow(m2,2));
			}
			else
			{
				var0 = 0;
				var1 = 0;
				var2 = 0;
			}
		
	
	//		std::cout<<"nb_pixels : "<<n<<std::endl;
	//		std::cout<<"vars :"<<var0<<" - "<<var1<<" - "<<var2<<std::endl;
	
			
//		for (auto it2 = voisins.begin(); it2 != voisins.end(); it2++ )
//		{
//			std::cout<<"voisins : "<<*it2<<std::endl;
//		}
//		
//		for (auto it = blocsLibres.begin(); it != blocsLibres.end(); it++ )
//		{
//			std::cout<<"bl : "<<*it<<std::endl;
//		}

/**
 * Lissage à utiliser uniquement sur une image traitée avec foregroundextraction
 */
Mat preciseSmoothing(Mat image, int nbrVoisin, int requis, Mat orig){
	
	Mat retour(image.size(), image.type());
	int count, total;
	int colonnes = image.cols;
	int lignes = image.rows;
	int iMax, jMax, iMin, jMin;
	Vec3b fond = Vec3b(BLUE, GREEN, RED);

	for(int x = 0; x < lignes; x++){
		for(int y = 0; y < colonnes; y++){
			retour.at<Vec3b>(x, y) = image.at<Vec3b>(x, y);
			if(image.at<Vec3b>(x,y) != fond){

				count = 0;
				total = 0;
				iMax = x + nbrVoisin;
				iMin = x - nbrVoisin;
				jMax = y + nbrVoisin;
				jMin = y - nbrVoisin;

				if(iMin < 0)
					iMin = nbrVoisin - x - nbrVoisin;
				if(iMax >= lignes)
					iMax = lignes - x;
				if(jMin < 0)
					jMin = nbrVoisin - y - nbrVoisin;
				if(jMax >= colonnes)
					jMax = colonnes - y;

				for(int i = iMin; i < iMax; i++){
					for(int j = jMin; j < jMax; j++){
						if(image.at<Vec3b>(i,j) != fond)
							count++;
						if(count > requis)
							break;
					}
					if(count > requis)
						break;
				}
				count--;
				if(count < requis){
					retour.at<Vec3b>(x,y) = fond;
				}
			}
		}
	}
	return retour;
}
