namedWindow("Originale", 1);
	namedWindow("Filtree", 1);
	char c;
	c = (char)waitKey(30);
	while(c != 'q' && !background.empty())
	{
		imshow("Filtree", background);
		imshow("Originale", frame);
		c = (char)waitKey(30);
	}
	
//ancienne fonction de comparaison pour l'extraction
if(pixelColorDifference(frame.at<Vec3b>(i,j), background.at<Vec3b>(i,j), seuil)){

/**
 * Renvoi vrai si la différence entre les couleurs des deux pixels est supérieure au seuil
 */
bool pixelColorDifference(Vec3b pixA, Vec3b pixB, double seuil);

/**
 * Renvoi vrai si la différence entre les couleurs des deux pixels est supérieure au seuil
 */
bool pixelColorDifference(Vec3b pixA, Vec3b pixB, double seuil){

	if(abs(pixA[0] - pixB[0]) > seuil||
			abs(pixA[1] - pixB[1]) > seuil ||
			abs(pixA[2] - pixB[2]) >seuil){
		return true;
	}
	return false;

}

 //res.at<Vec3b>(i,j) = frame.at<Vec3b>(i,j);
 //res.at<Vec3b>(i,j) = Vec3b(255,255,255);
 
 if(abs(frame.at<unsigned char>(i,j) - background.at<unsigned char>(i,j)) > seuil){
 res.at<unsigned char>(i,j) = frame.at<unsigned char>(i,j);
  res.at<unsigned char>(i,j) = 100;
  
  Mat temporalSmoothing(String filename){

    /*Résultat à renvoyer*/
    Mat background;
    /*Ensemble des 10 premières frames de la vidéos*/
    Mat stockage[10];
    /** Video*/
    VideoCapture vc = VideoCapture(filename);
    double h = 0.1;
    int res0, res1, res2;

    /*Récupération des dix premières images*/
    for(int i = 0; i< 10; i++){
        vc >> stockage[i];
    }
    background = Mat(stockage[0].size(), stockage[0].type());

    /*
     * Création d'une image dont chaque pixel correspond à la moyenne des 10 pixels
     * respectifs de chaque image
     */
    for(int x = 0; x < background.rows; x++){
        for(int y = 0; y < background.cols; y ++){
            for(int k = 0; k < 3; k++)
            {
                //calcul de la convolution pour chaque composante couleur
                res0 = res1 = res2 = 0;
                for (int u = 0; u < 10; u++)
                {
					res = res + (h*(stockage[u].at<Vec3b>(x, y)[k]));
                }
                background.at<Vec3b>(x,y)[k] = res;
            }

        }
    }
    vc.release();
    //spatialSmoothingAvgColor(background, 1);
    return background;
}
